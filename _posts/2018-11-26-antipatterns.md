---
layout: post
title: Why antipatterns exist?
categories: Senior_Seminar
---
Design patterns have been established to tackle common recurring problems that are encountered in software engineering. Programmers, engineers, and designers have iterated on these ideas; scrapping the ones that do not work or improving them to prevent common pitfalls to ensure usability, transparency, and modularity.

During the development of design patterns, there are ideas that looked promising at the beginning which turned out to be bad or ideas that programmers often come up with that lead to subpar design. These designs are called antipatterns. Antipatterns have been documented to provide guidance in the software development process and give fair warning against ideas that look promising but will actually bite them down the road. Antipatterns often look attractive in a narrow context but break apart in the general use case.

Anti-patterns exist for every stage of the process. There are antipatterns which are specific to programmers but there are antipatterns for managers and solution architects too. This article provides a comprehensive list of [antipatterns](http://wiki.c2.com/?AntiPatternsCatalog). Several experts have spent countless hours brainstorming these antipatterns and given their nature, each individual in the software development process will encounter them at least once. Just a quite read through the list can have hours and help conserve development time which can be used more productively somewhere else.

One of the patterns I like the most is the Vietnam War Anti Pattern.

>"I was told that this was a simple project that needed to be done, and should not take any longer than a few days. Unfortunately, it was a bigger task than envisioned so more resources were put into it, which stretched everything out, but at this point, we were committed. Now, someone is leaving. It's like the VietnamWar."

(from the antipattern website)

This antipattern is very common in software management. A manager sees a problem and then assigns it to a programmer or team without proper consultation. The problem is deceptive and looks quite easy. By the time the true complexity it discovered, too many resources have already been invested and doubling down the previous decision leads to a subpar product.
